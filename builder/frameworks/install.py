# LICENSE

import os, sys, time, pathlib
from os.path import join
from shutil import copyfile, rmtree
from platformio import proc

version = '0.0.0'
ver = {'PICO_SDK_VERSION_MAJOR':'0', 'PICO_SDK_VERSION_MINOR':'0', 'PICO_SDK_VERSION_REVISION':'0' }

def INFO(str, q = 0): 
    if q > 0:
        print('[INSTALL]', str) 

def DBG(str, q = 0):
    if q > 1:
        import inspect
        print( '[DBG] { %s() } %s' % (inspect.stack()[1][3], str))

def ERROR(txt):
    print('❖ ERROR ❖ [INSTALL]', txt)
    exit(-1)

def MKDIR(path, name):
    dir = join(path, name)
    if False == os.path.isdir( dir ):
        try:
            os,os.mkdir(dir)
        except OSError:
            ERROR ("[ERROR] Creation of the directory %s failed" % dir)
    return dir

###############################################################################

def get_ver(i, k):
    if k in i: 
        x = i.find(' ')
        y = i.find(')')
        if x > -1 and y > -1:
            ver[k] = i[x+1:y]

def get_version( pico_dir ):
    global version
    f = open( join( pico_dir, 'pico_sdk_version.cmake' ) )
    t = f.read()
    f.close()    
    t = t.strip().split('\n')
    for i in t:
        if False == i.startswith('set(') or i.find(')') == -1 or i.find('$') > -1: continue
        get_ver(i, 'PICO_SDK_VERSION_MAJOR')
        get_ver(i, 'PICO_SDK_VERSION_MINOR')
        get_ver(i, 'PICO_SDK_VERSION_REVISION')
    version = '%s.%s.%s' % ( ver['PICO_SDK_VERSION_MAJOR'], ver['PICO_SDK_VERSION_MINOR'], ver['PICO_SDK_VERSION_REVISION'] ) 
    str = 'PICO-SDK      : %s' % version     
    INFO( str )
    return str

###############################################################################

def create_folder_gcc( pico_dir ):
    p = join( pico_dir, 'gcc' )
    if os.path.exists( p ): 
        return
    MKDIR( pico_dir, 'gcc' )
    f = open( join( p, 'gcc-syscall.c' ), 'w' )
    f.write(
'''
#include <sys/stat.h>
extern int __attribute__((weak)) _fstat(int file, struct stat *st){ st->st_mode = S_IFCHR; return 0; }
extern int __attribute__((weak)) _close(int file) { return -1; }
extern int __attribute__((weak)) _isatty(int file) { return 1; }
extern int __attribute__((weak)) _lseek(int file, int ptr, int dir) { return 0; }
extern int __attribute__((weak)) _read(int handle, char *buffer, int length) { return -1; }
extern int __attribute__((weak)) _write(int handle, char *buffer, int length) { return -1; }
'''        
    )
    f.close()

def create_folder_inc(pico_dir, platformio_dir):
    p = join( platformio_dir, 'inc' )
    if os.path.exists( p ): 
        return
    MKDIR( platformio_dir, 'inc' )
    for root, dirs, files in os.walk( pico_dir ):
        root = root.replace('\\', '/')
        if '/lib' in root: continue
        if '/host' in root: continue
        if 'include' not in root: continue       
        name = root[ root.index('include') + 8:]
        MKDIR( join( pico_dir, p), name )
        for file in files:
            ext = pathlib.Path(file).suffix
            if ext == '.h' or ext == '.S':
                src_file = join(root, file)
                dst_file = join(p, name, file)
                if False == os.path.exists( dst_file ): 
                    copyfile( src_file, dst_file ) 
                else: 
                    ERROR('FILE EXISTS: %s' % join(root, file))

###############################################################################

# TODO check dst folder
def create_config_autogen( pico_dir ): # ...\pico-sdk\src\rp2_common\pico_platform\include\pico
    path = join( pico_dir, 'src', 'rp2_common', 'pico_platform', 'include', 'pico', 'config_autogen.h' )
    if os.path.exists( path ): 
        return
    f = open( path, 'w' ) 
    f.write('// config autogen: PlatformIO')
    f.close()

# TODO check dst folder
def create_version( pico_dir ): # ...\pico-sdk\src\rp2_common\pico_platform\include\pico
    global version
    path = join( pico_dir, 'src', 'rp2_common', 'pico_platform', 'include', 'pico', 'version.h')
    if os.path.exists( path ): 
        return
    f = open( path, 'w' ) 
    s = '''
/*
 * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * 
 * PlatformIO - WizIO
 * https://github.com/
 */

// ---------------------------------------
// THIS FILE IS AUTOGENERATED; DO NOT EDIT
// ---------------------------------------

#ifndef _PICO_VERSION_H
#define _PICO_VERSION_H

#define PICO_SDK_VERSION_MAJOR      %s
#define PICO_SDK_VERSION_MINOR      %s
#define PICO_SDK_VERSION_REVISION   %s
#define PICO_SDK_VERSION_STRING     "%s < PlatformIO >"

#endif
''' % ( ver['PICO_SDK_VERSION_MAJOR'], ver['PICO_SDK_VERSION_MINOR'], ver['PICO_SDK_VERSION_REVISION'],  version )    
    f.write(s)
    f.close()

###############################################################################

def create_patch( pico_dir ):
    get_version(pico_dir)
    create_config_autogen(pico_dir)   
    create_version(pico_dir)    

    platformio_dir = join( pico_dir, 'platformio' )
    if not os.path.exists( platformio_dir ): 
        MKDIR( pico_dir, 'platformio' )

    create_folder_inc(pico_dir, platformio_dir) 
    create_folder_gcc(platformio_dir) 

def dev_install( framework_dir, q = 0 ):
    global version    

    if not os.path.exists( framework_dir ):  
        DBG('[---] Framework dir not exists', q)
        return 

    pico = join( framework_dir, 'pico-sdk' )
    #DBG('pico path: %s' % pico, q)

    if os.path.exists( pico ):  
        create_patch( pico ) # if manual install
        DBG('pico-sdk exists', q)
        return 

    ## CLONE BEGIN ####################

    start_time = time.time()
    INFO('Clone pico-sdk ( less than a minute, Plese wait )', q)
    args = [ 'git', 'clone', 'https://github.com/raspberrypi/pico-sdk', pico ]
    res = proc.exec_command( args, stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin )
    
    if 0 == res['returncode']: 
        INFO('Init submodules ...', q)
        args = ['git', 'submodule', 'init']
        res = proc.exec_command( args, stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin, cwd = pico )

        if 0 == res['returncode']: 
            INFO('Update submodules ...', q)
            args = ['git', 'submodule', 'update', pico  ]
            res = proc.exec_command( args, stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin, cwd = pico )
           
    if 0 != res['returncode']:  
        rmtree(pico, ignore_errors=False)
        ERROR('Result:%d ... Please, try later' % res)

    ## CLONE END   ####################

    create_patch( pico ) 
    INFO('PICO-SDK Version: %s' % version, q )
    INFO('DONE ( %s sec )' % int( time.time() - start_time ), q ) # [INSTALL] DONE ( 24 sec )